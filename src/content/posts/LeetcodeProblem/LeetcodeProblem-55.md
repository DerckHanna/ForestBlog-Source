---
title: LeetcodeProblem-55
published: 0000-00-55
description: '力扣第55题'
image: "./LeetcodeLogo.png"
tags: [Leetcode]
category: 'Leetcode'
draft: false 
---

---

## 题目描述

给定一个非负整数数组 `nums`，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true`；否则，返回 `false`。

### 示例 1

**输入：** `nums = [2,3,1,1,4]`  
**输出：** `true`  
**解释：** 可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

### 示例 2

**输入：** `nums = [3,2,1,0,4]`  
**输出：** `false`  
**解释：** 无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0，所以永远不可能到达最后一个下标。

### 提示

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10`

## 题解

### 思路一：贪心

如果一个位置`pos`是可达的,那么从该位置到`pos + num[pos]`的位置都是可达的

考虑维护一个变量`Max`,用于记录当遍历数组至某一位置时，最远的可达位置

遍历数组，每到达一个新的位置`i`:
    - 若`Max < i`,那么`return false`
    - 更新`Max`,`Max = max(Max, i + nums[i])`
    - 若`Max >= nums.length - 1`(下标从0开始),那么`return true`

#### 时间复杂度

$$O(N)$$

#### 代码

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int Max = 0;
        for(int i = 0; i < nums.size(); i++){
            if(Max < i)return false;
            Max = max(Max, i + nums[i]);
            if(Max >= nums.size() - 1)return true;
        }
        return false;
    }
};
```

---

### 思路二：动态规划

1. 考虑一个一维数组`dp`，遍历数组到某一位置`i`时,`dp[i]`的定义为`在位置i能走的最大步数`

2. 设计`dp`数组的状态转移方程，遍历数组，当前位置的`dp[i]`为`dp[i-1]再走一步的剩余步数`和`nums[i]`中的最大值，那么有状态转移方程`dp[i] = max(dp[i-1] - 1, nums[i])`

3. 边界条件(初始化)：`dp[0] = nums[0]`

4. 遍历数组，到新位置即进行状态转移，更新`dp[i]`,之后判断`dp[i]`是否为0，是，则无法前进了，`return false`,不是则继续遍历，若最终退出了遍历循环，那么说明角色可以到达终点

5. 考虑优化：当前状态之和上一次的状态有关，可以使用滚动变量进行优化

#### 时间复杂度

$$O(N)$$

#### 代码

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int dp = -1;// 第1步的上一步不存在，初始化为-1
        for(int i = 0; i < nums.size(); i++)
        {
            if(!dp)return false;
            dp = max(dp - 1, nums[i]); 
        }
        return true;
    }
};
```

:::caution[注意]
**dp判0的语句必须放置在状态更新的语句之后:**

当`i = nums.size()-1`时，若`nums[i] = 0`并且`dp = 1`,状态更新之后,在最后一个位置能走的最大步数为0，`return false`,但是此时我们已经到终点,于是结果出错
:::

### DFS的错误

#### 爆搜思路

由于此题的数量级为1e4,数据较小，那么尝试从起点开始搜索，尝试去到距离起点最远可达处x，再从x的最远可达处进行尝试，最终看能否到达终点，这样依次尝试至最靠近起点的位置，即可求得答案

#### 时间复杂度

当数组呈现`{n}、{n-1}……、{2}、{1}、{0}、{0}`的模样时，时间复杂度将达到$O(n!)$

:::tip[e.g.]
如5、4、3、2、1、0、0
1. 从起点`5`出发，到`0`,无法前进
2. 退一步，到达`1`,`1`前进一步到达`0`,无法前进
3. 退一步，到达`2`,`2`前进两步到达`0`,无法前进,……以此类推
对于`5`,它会使得角色到`4`、`3`、`2`、`1`、`0`
对于`4`,它会使得角色到`3`、`2`、`1`、`0`

……

以此类推

:::
