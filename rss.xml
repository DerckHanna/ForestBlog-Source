<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Forest</title><description>Code and Grow</description><link>https://derckhanna.github.io/ForestBlog-Source/</link><language>zh_CN</language><item><title>Proposed-学习规划</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/%E6%8B%9F-%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/%E6%8B%9F-%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</guid><description>How to study</description><pubDate>Tue, 02 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;C++后端开发工程师学习路线图&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一份以就业为导向的渐进式学习指南&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;📍 总体原则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优先级标记&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;P0&lt;/strong&gt; (最高): 必须精通，面试必考，日常开发必用。投入70%精力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P1&lt;/strong&gt; (高): 需要熟练掌握，是构建完整知识体系和项目的关键。投入20%精力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P2&lt;/strong&gt; (中): 扩展项，用于冲击高阶岗位和技术深度。投入10%精力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P3&lt;/strong&gt; (低): 特定领域方向，按需学习。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实践为王&lt;/strong&gt;：理论学习和代码实践时间比例至少 &lt;strong&gt;1:2&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标驱动&lt;/strong&gt;：每个阶段都要用&lt;strong&gt;项目成果&lt;/strong&gt;来检验学习效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;🧭 学习阶段导航&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;第一阶段：基础入门与核心语言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：熟练掌握C++现代语法和核心特性，能编写健壮的命令行程序。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;学习内容&lt;/th&gt;
&lt;th&gt;Level&lt;/th&gt;
&lt;th&gt;具体要点&lt;/th&gt;
&lt;th&gt;学习建议与目标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;C++基础语法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;变量、类型、运算符、流程控制、函数&lt;/td&gt;
&lt;td&gt;快速过，巩固基础。完成教材习题。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;复合数据类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;数组、&lt;code&gt;std::string&lt;/code&gt;、结构体&lt;/td&gt;
&lt;td&gt;理解内存布局。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;指针与引用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指针运算、指针与数组、引用本质&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;重中之重&lt;/strong&gt;，必须彻底理解。是后续学习的基础。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;开发环境搭建&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Linux基础命令&lt;/strong&gt;、VSCode/CLion配置、&lt;strong&gt;Git基本使用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;必须在&lt;strong&gt;Linux环境&lt;/strong&gt;(WSL2或虚拟机)下进行所有开发。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;代码规范&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Google C++ Style Guide&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;需要什么才学习什么&lt;/strong&gt;，此文章作为参考&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;开发工具&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Vim&lt;/td&gt;
&lt;td&gt;学到&lt;strong&gt;纯熟&lt;/strong&gt;的地步，大幅提高码代码效率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;项目实践&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;完成&lt;strong&gt;LeetCode&lt;/strong&gt;简单/中等难度题目50道&lt;/td&gt;
&lt;td&gt;使用C++和STL，巩固语法。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;第二阶段：核心深化与现代C++&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：深入理解OOP、内存管理、STL，掌握现代C++特性，写出安全、现代的C++代码。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;学习内容&lt;/th&gt;
&lt;th&gt;Level&lt;/th&gt;
&lt;th&gt;具体要点&lt;/th&gt;
&lt;th&gt;学习建议与目标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;面向对象编程(OOP)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;类、封装、构造函数/析构函数、继承、&lt;strong&gt;多态(虚函数)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;面试绝对核心&lt;/strong&gt;。理解vptr和vtable。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;内存管理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;、&lt;strong&gt;RAII机制&lt;/strong&gt;、&lt;strong&gt;智能指针&lt;/strong&gt;(&lt;code&gt;unique_ptr&lt;/code&gt;, &lt;code&gt;shared_ptr&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用智能指针彻底替代裸指针&lt;/strong&gt;。理解所有权概念。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;标准模板库(STL)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;序列容器&lt;/strong&gt;(&lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;deque&lt;/code&gt;)、&lt;strong&gt;关联容器&lt;/strong&gt;(&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;unordered_map&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;掌握每种容器的&lt;strong&gt;底层实现、时间复杂度、适用场景&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;STL算法与迭代器&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;常用算法(&lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;)、迭代器类别&lt;/td&gt;
&lt;td&gt;告别循环，多用算法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;现代C++特性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;auto&lt;/code&gt;、&lt;code&gt;nullptr&lt;/code&gt;、范围&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;Lambda&lt;/code&gt;表达式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在现代C++代码中无处不在，必须熟练。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;右值引用与移动语义&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;std::move&lt;/code&gt;&lt;/strong&gt;、移动构造函数、移动赋值运算符&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;性能优化关键&lt;/strong&gt;，面试高频。理解其如何避免拷贝。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;调试与工具&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;GDB&lt;/strong&gt;基本调试命令、&lt;strong&gt;CMake&lt;/strong&gt;基本语法&lt;/td&gt;
&lt;td&gt;会用GDB调试段错误、内存错误。会用CMake管理多文件项目。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;项目实践&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1. &lt;strong&gt;LeetCode&lt;/strong&gt;刷题至150道。&amp;lt;br&amp;gt;2. 实现一个&lt;strong&gt;综合性的班级管理系统&lt;/strong&gt;（使用OOP、STL、文件IO）。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;第三阶段：进阶精通与并发编程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：攻克并发编程，理解模板元编程，具备排查复杂问题和阅读源码的能力。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;学习内容&lt;/th&gt;
&lt;th&gt;Level&lt;/th&gt;
&lt;th&gt;具体要点&lt;/th&gt;
&lt;th&gt;学习建议与目标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;并发编程&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::thread&lt;/code&gt;, &lt;code&gt;std::async&lt;/code&gt;, &lt;code&gt;std::future&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;创建和管理线程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;并发同步与互斥&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;std::mutex&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;std::lock_guard&lt;/code&gt;/&lt;code&gt;std::unique_lock&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;std::condition_variable&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;解决数据竞争和条件同步问题&lt;/strong&gt;，面试必考。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;原子操作与内存模型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::atomic&lt;/code&gt;、内存顺序（初步了解）&lt;/td&gt;
&lt;td&gt;理解无锁编程的基础。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;模板编程&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;函数模板、类模板、模板特化&lt;/td&gt;
&lt;td&gt;理解STL的基础，能编写泛型代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;单例&lt;/strong&gt;、&lt;strong&gt;工厂&lt;/strong&gt;、&lt;strong&gt;观察者&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;理解常见场景下的解决方案，写出优雅代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能分析工具&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Valgrind&lt;/strong&gt;(memcheck)、&lt;code&gt;perf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用Valgrind排查&lt;strong&gt;内存泄漏&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;项目实践&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1. &lt;strong&gt;LeetCode&lt;/strong&gt;多线程题目。&amp;lt;br&amp;gt;2. 实现一个&lt;strong&gt;简单的线程池&lt;/strong&gt;。&amp;lt;br&amp;gt;3. 阅读&lt;strong&gt;LevelDB&lt;/strong&gt;或&lt;strong&gt;Redis&lt;/strong&gt;的部分源码。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;第四阶段：生态应用与后端开发&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：将C++知识应用于网络、数据库等后端领域，构建可用的服务，积累项目经验。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;学习内容&lt;/th&gt;
&lt;th&gt;Level&lt;/th&gt;
&lt;th&gt;具体要点&lt;/th&gt;
&lt;th&gt;学习建议与目标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;计算机网络基础&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;TCP/IP模型&lt;/strong&gt;、&lt;strong&gt;TCP/UDP协议&lt;/strong&gt;、&lt;strong&gt;HTTP协议&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;必懂&lt;/strong&gt;，不需要深入细节，但必须清楚流程和概念。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Socket网络编程&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Socket API、编写TCP/UDP客户端/服务器&lt;/td&gt;
&lt;td&gt;理解网络编程的基本范式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;高性能网络编程&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;I/O多路复用&lt;/strong&gt;：&lt;strong&gt;&lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt;/&lt;code&gt;epoll&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Linux下C++后端核心技能&lt;/strong&gt;，面试高频。重点学习&lt;code&gt;epoll&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数据库基础&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;SQL语言&lt;/strong&gt;、MySQL/PostgreSQL基本操作&lt;/td&gt;
&lt;td&gt;会写复杂的SQL查询。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;C++操作数据库&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;mysql-connector-cpp&lt;/code&gt;或&lt;code&gt;libpqxx&lt;/code&gt;连接并操作数据库&lt;/td&gt;
&lt;td&gt;将数据库融入你的C++项目。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;序列化&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;JSON&lt;/strong&gt;（推荐&lt;code&gt;nlohmann/json&lt;/code&gt;库）&lt;/td&gt;
&lt;td&gt;Web通信和配置的标准格式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Web框架&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;使用&lt;strong&gt;Drogon&lt;/strong&gt;或&lt;strong&gt;Crow&lt;/strong&gt;框架快速开发RESTful API&lt;/td&gt;
&lt;td&gt;感受现代C++Web开发流程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;项目实践&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;【终极项目】&lt;/strong&gt;：实现一个基于**&lt;code&gt;epoll&lt;/code&gt;&lt;strong&gt;的&lt;/strong&gt;高性能HTTP服务器**，支持静态资源请求和API路由。&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;这是你简历上最闪亮的项目&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;第五阶段：复习、面试与实习&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：整合知识，查漏补缺，准备面试，获得实习/工作Offer。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;系统复习&lt;/strong&gt;：根据上述路线图，重新回顾P0和P1内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面试准备&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;算法&lt;/strong&gt;：刷《&lt;strong&gt;剑指Offer&lt;/strong&gt; 》和LeetCode热门100题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;八股文&lt;/strong&gt;：整理操作系统、计算机网络、数据库、C++语言核心的面试题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;项目复盘&lt;/strong&gt;：深入复盘你的“HTTP服务器”项目，能清晰讲述技术选型、难点和优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简历投递&lt;/strong&gt;：大三暑假的实习至关重要，是你进入大厂的跳板。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;✅ 总结&lt;/h2&gt;
&lt;p&gt;这份路线图的核心是：&lt;strong&gt;“先语言核心，后系统应用；先底层基础，后高层框架”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;记住，&lt;strong&gt;深度优于广度&lt;/strong&gt;。彻底理解一个&lt;code&gt;epoll&lt;/code&gt;的原理，远比泛泛地了解十个框架更有价值。祝你学有所成，拿到心仪的Offer！&lt;/p&gt;
</content:encoded></item><item><title>元学习</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/%E5%85%83%E5%AD%A6%E4%B9%A0/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/%E5%85%83%E5%AD%A6%E4%B9%A0/</guid><pubDate>Mon, 01 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;&quot;元学习&quot;模型&lt;/h1&gt;
&lt;p&gt;元学习的目的便是 &lt;strong&gt;“学会如何学习”&lt;/strong&gt;，回答下面的问题，构建一个高效、自适应、可持续的个人学习系统(针对学习规划中的某一学习内容)&lt;/p&gt;
&lt;h2&gt;--- 学习前解决↓---&lt;/h2&gt;
&lt;h2&gt;一、明确学习动机与目标&lt;/h2&gt;
&lt;p&gt;元学习的起点 —— 先明确 “学习的价值锚点”，避免盲目跟风&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我学习这个的&lt;strong&gt;核心动机&lt;/strong&gt;是什么？&lt;/li&gt;
&lt;li&gt;这个学习目标和我的&lt;strong&gt;长期规划 / 当下需求&lt;/strong&gt;是否匹配？&lt;/li&gt;
&lt;li&gt;我需要学到 “什么程度” 才算 “学会”？&lt;/li&gt;
&lt;li&gt;这个目标是否需要&lt;strong&gt;拆解&lt;/strong&gt;？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;二、学习方法与策略&lt;/h2&gt;
&lt;p&gt;元学习的核心环节 —— 避免 “用低效方法硬熬”&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我当前(准备)用的学习方法，&lt;strong&gt;能高效达到目标吗&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;这个领域有没有 “更适配的经典学习策略”？&lt;/li&gt;
&lt;li&gt;我需要先补哪些 &lt;strong&gt;“基础能力”&lt;/strong&gt;，才能避免卡壳？&lt;/li&gt;
&lt;li&gt;遇到 “学不会的难点” 时，我是该“死磕” 还是 “换思路”？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;--- 学习后解决↓---&lt;/h2&gt;
&lt;h2&gt;三、学习过程监控&lt;/h2&gt;
&lt;p&gt;元学习的 “实时校准环节”—— 避免 “学了一半才发现方向偏了” 或 “进度失控”。核心是 “动态追踪学习状态，及时修正偏差”。&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我每天 / 每周的学习进度，是否符合之前的计划？&lt;/li&gt;
&lt;li&gt;学习时我是否容易分心？(用物理量化,不要用抽象词概括)&lt;/li&gt;
&lt;li&gt;学完一个章节后，我能 “立刻回忆起核心内容” 吗？(若合上书就忘，说明 “输入时没主动思考”)&lt;/li&gt;
&lt;li&gt;这个阶段的学习，让我 “有成就感” 还是 “焦虑”？（若持续焦虑，可能是目标定太高或方法不对，需降低短期目标或换更简单的入门内容）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;四、学习结果评估&lt;/h2&gt;
&lt;p&gt;元学习的 “效果验证环节”—— 避免 “自我感觉学会了，实际不会用”。核心是 “用‘输出’或‘解决问题’验证学习效果”，而非 “看了多少课、记了多少笔记”。&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我能通过 “&lt;strong&gt;输出&lt;/strong&gt;” 证明自己学会了吗？&lt;/li&gt;
&lt;li&gt;这个知识 / 技能，我能 “和已有的知识联系起来” 吗？&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;用 1-10 分打分&lt;/strong&gt;，我对这个知识 / 技能的掌握程度是多少？分数低的原因是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;五、学习迭代优化&lt;/h2&gt;
&lt;p&gt;元学习的 “循环升级环节”—— 让每次学习都成为 “下一次学习的经验”，避免 “重复踩同一个坑”。核心是 “总结本次学习的经验教训，优化下一次的学习策略”。&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这次学习中，哪些做法 “有效”，下次可以保留？&lt;/li&gt;
&lt;li&gt;哪些做法 “无效”，下次需要改掉？&lt;/li&gt;
&lt;li&gt;如果重新学一遍，我会 “调整哪些环节”？&lt;/li&gt;
&lt;li&gt;这次学习，我的 “学习能力”（比如专注力、理解力、复盘能力）有没有提升？怎么提升的？（比如通过 “每天复盘”，发现自己的 “问题分析能力” 变强了）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
</content:encoded></item><item><title>Markdown 扩展功能</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/markdown-extended/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/markdown-extended/</guid><description>了解更多关于 Fuwari 中的 Markdown 功能</description><pubDate>Wed, 01 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;GitHub 仓库卡片&lt;/h2&gt;
&lt;p&gt;您可以添加动态卡片链接到 GitHub 仓库，页面加载时，仓库信息会从 GitHub API 获取。&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;Fabrizz/MMM-OnSpotify&quot;}&lt;/p&gt;
&lt;p&gt;使用代码 &lt;code&gt;::github{repo=&quot;&amp;lt;所有者&amp;gt;/&amp;lt;仓库名&amp;gt;&quot;}&lt;/code&gt; 创建 GitHub 仓库卡片。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::github{repo=&quot;saicaca/fuwari&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;警示框 (Admonitions)&lt;/h2&gt;
&lt;p&gt;支持以下类型的警示框: &lt;code&gt;note(备注)&lt;/code&gt; &lt;code&gt;tip(提示)&lt;/code&gt; &lt;code&gt;important(重要)&lt;/code&gt; &lt;code&gt;warning(警告)&lt;/code&gt; &lt;code&gt;caution(注意)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;:::note
突出显示用户应该注意的信息，即使在快速浏览时也是如此。
:::&lt;/p&gt;
&lt;p&gt;:::tip
辅助用户更好行动的可选信息。
:::&lt;/p&gt;
&lt;p&gt;:::important
用户所需的关键信息。
:::&lt;/p&gt;
&lt;p&gt;:::warning
由于潜在风险而需要用户立即关注的关键内容。
:::&lt;/p&gt;
&lt;p&gt;:::caution
某个行动可能带来的负面后果。
:::&lt;/p&gt;
&lt;h3&gt;基本语法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;:::note
Highlights information that users should take into account, even when skimming.
:::

:::tip
Optional information to help a user be more successful.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义标题&lt;/h3&gt;
&lt;p&gt;可以自定义警示框的标题。&lt;/p&gt;
&lt;p&gt;:::note[我的自定义标题]
这是一个带有自定义标题的备注。
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;GitHub 语法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
&lt;a href=&quot;https://github.com/orgs/community/discussions/16925&quot;&gt;GitHub 语法&lt;/a&gt; 也受支持.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [!NOTE]
&amp;gt; GitHub 语法也受支持。

&amp;gt; [!TIP]
&amp;gt; GitHub 语法也受支持。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;隐藏内容 (Spoiler)&lt;/h3&gt;
&lt;p&gt;您可以在文本中添加隐藏内容。该内容也支持 &lt;strong&gt;Markdown&lt;/strong&gt; 语法.&lt;/p&gt;
&lt;p&gt;这个内容 : spoiler [ 是隐藏的 &lt;strong&gt;哈哈&lt;/strong&gt; ] !&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
The content : spoiler[is hidden **ayyy**]!
// 孩子们，这个功能似乎用不了

&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Expressive Code 代码展示示例</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/expressive-code/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/expressive-code/</guid><description>使用 Expressive Code 在 Markdown 中展示代码块的效果</description><pubDate>Wed, 10 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在这里，我们将探索使用 &lt;a href=&quot;https://expressive-code.com/&quot;&gt;Expressive Code&lt;/a&gt; 的代码块显示效果。提供的示例基于官方文档，您可以参考获取更多详细信息。&lt;/p&gt;
&lt;h2&gt;Expressive Code 功能&lt;/h2&gt;
&lt;h3&gt;语法高亮&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/syntax-highlighting/&quot;&gt;语法高亮&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;常规语法高亮&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;这段代码有语法高亮效果!&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;渲染 ANSI 转义序列&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ANSI 颜色：
- 常规：[31m红色[0m [32m绿色[0m [33m黄色[0m [34m蓝色[0m [35m洋红色[0m [36m青色[0m
- 粗体：[1;31m红色[0m [1;32m绿色[0m [1;33m黄色[0m [1;34m蓝色[0m [1;35m洋红色[0m [1;36m青色[0m
- 暗淡：[2;31m红色[0m [2;32m绿色[0m [2;33m黄色[0m [2;34m蓝色[0m [2;35m洋红色[0m [2;36m青色[0m

256 色（显示颜色 160-177）：
[38;5;160m160 [38;5;161m161 [38;5;162m162 [38;5;163m163 [38;5;164m164 [38;5;165m165[0m
[38;5;166m166 [38;5;167m167 [38;5;168m168 [38;5;169m169 [38;5;170m170 [38;5;171m171[0m
[38;5;172m172 [38;5;173m173 [38;5;174m174 [38;5;175m175 [38;5;176m176 [38;5;177m177[0m

全 RGB 颜色：
[38;2;34;139;34m森林绿 - RGB(34, 139, 34)[0m

文本格式：[1m粗体[0m [2m暗淡[0m [3m斜体[0m [4m下划线[0m

格式是: [ 配置 内容  [ 0m
[3m实际使用的时候将上面的文本连在一起[0m
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;编辑器与终端框架&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/frames/&quot;&gt;编辑器与终端框架&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;代码编辑器框架&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;标题属性示例&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- src/content/index.html --&amp;gt;
&amp;lt;div&amp;gt;文件名注释示例&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;终端框架&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;这个终端框架没有标题&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;Write-Output &quot;这个有标题!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;覆盖框架类型&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;看，没有框架!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;# 如果不覆盖，这应该是一个终端框架
function Watch-Tail { Get-Content -Tail 20 -Wait $args }
New-Alias tail Watch-Tail
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;文本与行标记&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/text-markers/&quot;&gt;文本与行标记&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;标记整行和行范围js {1, 4, 7-8}&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 第 1 行 - 通过行号标记
// 第 2 行
// 第 3 行
// 第 4 行 - 通过行号标记
// 第 5 行
// 第 6 行
// 第 7 行 - 通过范围 &quot;7-8&quot; 标记
// 第 8 行 - 通过范围 &quot;7-8&quot; 标记
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;选择行标记类型 (mark, ins, del)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  console.log(&apos;这行标记为已删除&apos;)
  // 这行和下一行标记为已插入
  console.log(&apos;这是第二个插入的行&apos;)

  return &apos;这行使用中性的默认标记类型&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;为行标记添加标签jsx {&quot;1&quot;:5} del={&quot;2&quot;:7-8} ins={&quot;3&quot;:10-12}&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 带标签的行标记.jsx
&amp;lt;button
  role=&quot;button&quot;
  {...props}
  value={value}
  className={buttonClassName}
  disabled={disabled}
  active={active}
&amp;gt;
  {children &amp;amp;&amp;amp;
    !active &amp;amp;&amp;amp;
    (typeof children === &apos;string&apos; ? &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt; : children)}
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;在单独行上添加长标签&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;jsx {&quot;1. Provide the value prop here:&quot;:5-6} del={&quot;2. Remove the disabled and active states:&quot;:8-10} ins={&quot;3. Add this to render the children inside the button:&quot;:12-15}&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 带标签的行标记.jsx
&amp;lt;button
  role=&quot;button&quot;
  {...props}

  value={value}
  className={buttonClassName}

  disabled={disabled}
  active={active}
&amp;gt;

  {children &amp;amp;&amp;amp;
    !active &amp;amp;&amp;amp;
    (typeof children === &apos;string&apos; ? &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt; : children)}
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用类似 diff 的语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;+这行将标记为已插入
-这行将标记为已删除
这是常规行
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;--- a/README.md
+++ b/README.md
@@ -1,3 +1,4 @@
+这是一个实际的 diff 文件
-所有内容将保持未修改状态
 也不会删除任何空白字符
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;结合语法高亮和类似 diff 的语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  function thisIsJavaScript() {
    // 整个代码块将作为 JavaScript 高亮，
    // 我们仍然可以为其添加 diff 标记！
-   console.log(&apos;要移除的旧代码&apos;)
+   console.log(&apos;全新闪亮的代码!&apos;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;标记行内的特定文本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  // Mark any given text inside lines
  return &apos;Multiple matches of the given text are supported&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;正则表达式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;The words yes and yep will be marked.&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;转义正斜杠&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;Test&quot; &amp;gt; /home/test.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;选择行内标记类型 (mark, ins, del)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  console.log(&apos;These are inserted and deleted marker types&apos;);
  // The return statement uses the default marker type
  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自动换行&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/word-wrap/&quot;&gt;自动换行&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;按代码块配置自动换行&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Example with wrap
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(启用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// Example with wrap=false
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(禁用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;配置换行行的缩进&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Example with preserveIndent (enabled by default)
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(启用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// Example with preserveIndent=false
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(禁用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;可折叠部分&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/plugins/collapsible-sections/&quot;&gt;可折叠部分&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 所有这些样板设置代码将被折叠
import { someBoilerplateEngine } from &apos;@example/some-boilerplate&apos;
import { evenMoreBoilerplate } from &apos;@example/even-more-boilerplate&apos;

const engine = someBoilerplateEngine(evenMoreBoilerplate())

// 这部分代码默认可见
engine.doSomething(1, 2, 3, calcFn)

function calcFn() {
  // 可以有多个折叠部分
  const a = 1
  const b = 2
  const c = a + b

  // 这将保持可见
  console.log(`计算结果: ${a} + ${b} = ${c}`)
  return c
}

// 从这到代码块末尾的所有代码将再次被折叠
engine.closeConnection()
engine.freeMemory()
engine.shutdown({ reason: &apos;示例样板代码结束&apos; })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;行号&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/plugins/line-numbers/&quot;&gt;行号&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;按代码块显示行号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 这个代码块将显示行号
console.log(&apos;来自第 2 行的问候!&apos;)
console.log(&apos;我在第 3 行&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// 这个代码块禁用了行号
console.log(&apos;你好?&apos;)
console.log(&apos;抱歉，你知道我在第几行吗?&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;更改起始行号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;来自第 5 行的问候!&apos;)
console.log(&apos;我在第 6 行&apos;)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Fuwari 简单使用指南</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/guide/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/guide/</guid><description>如何使用此博客模板</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面图片来源: &lt;a href=&quot;https://image.civitai.com/xG1nkqKTMzGDvpLrqFT7WA/208fc754-890d-4adb-9753-2c963332675d/width=2048/01651-1456859105-(colour_1.5),girl,_Blue,yellow,green,cyan,purple,red,pink,_best,8k,UHD,masterpiece,male%20focus,%201boy,gloves,%20ponytail,%20long%20hair,.jpeg&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此博客模板基于 &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt; 构建。本指南未提及的内容，您可以在 &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro 文档&lt;/a&gt; 中找到答案。&lt;/p&gt;
&lt;h2&gt;文章的前言部分 (Front-matter)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: 我的第一篇博客文章
published: 2023-09-09
description: 这是我的新 Astro 博客的第一篇文章
image: ./cover.jpg
tags: [示例标签1, 示例标签2]
category: 前端开发
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章发布的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的简短描述。在首页显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The cover image path of the post.&amp;lt;br/&amp;gt;1. Start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: Use web image&amp;lt;br/&amp;gt;2. Start with &lt;code&gt;/&lt;/code&gt;: For image in &lt;code&gt;public&lt;/code&gt; dir&amp;lt;br/&amp;gt;3. With none of the prefixes: Relative to the markdown file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的分类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果文章仍是草稿，则不会显示&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;image翻译:
文章的封面图片路径。
1. 以 http:// 或 https:// 开头：使用网络图片
2. 以 / 开头：位于 public 目录中的图片
3. 无前缀：相对于 markdown 文件的路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;文章文件的存放位置&lt;/h2&gt;
&lt;p&gt;您的文章文件应放置在&lt;code&gt;src/content/posts/&lt;/code&gt; 目录下。您也可以创建子目录来更好地组织文章和资源文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Markdown 示例</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/markdown/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/markdown/</guid><description>一个简单的 Markdown 博客文章示例</description><pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;一级标题&lt;/h1&gt;
&lt;p&gt;段落之间用空行分隔。&lt;/p&gt;
&lt;p&gt;第二段落。&lt;em&gt;斜体&lt;/em&gt;、&lt;strong&gt;粗体&lt;/strong&gt;和&lt;code&gt;等宽字体&lt;/code&gt;。项目列表看起来像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个项目&lt;/li&gt;
&lt;li&gt;那个项目&lt;/li&gt;
&lt;li&gt;另一个项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意 --- 不考虑星号 --- 实际文本内容从第4列开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;块引用是
这样写的。&lt;/p&gt;
&lt;p&gt;如果你喜欢，它们可以
跨多个段落。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用3个破折号表示长破折号。使用2个破折号表示范围（例如，&quot;全部在第12--14章&quot;）。三个点...将被转换为省略号。
支持Unicode。☺&lt;/p&gt;
&lt;h2&gt;二级标题&lt;/h2&gt;
&lt;p&gt;这是一个编号列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再次注意实际文本如何从第4列开始（距离左侧4个字符）。这是一个代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 让我重申...
for i in 1 .. 10 { do-something(i) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如您所猜，缩进4个空格。顺便说一下，您可以使用分隔块来代替缩进块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define foobar() {
    print &quot;Welcome to flavor country!&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（这样更容易复制和粘贴）。您可以选择标记分隔块以便Pandoc进行语法高亮：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
# 快，数到十！
for i in range(10):
    # （但不要*太*快）
    time.sleep(0.5)
    print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;三级标题&lt;/h3&gt;
&lt;p&gt;现在是一个嵌套列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, get these ingredients:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;carrots&lt;/li&gt;
&lt;li&gt;celery&lt;/li&gt;
&lt;li&gt;lentils&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boil some water.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dump everything in the pot and follow
this algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; find wooden spoon
 uncover pot
 stir
 cover pot
 balance wooden spoon precariously on pot handle
 wait 10 minutes
 goto first step (or shut off burner when done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do not bump wooden spoon or it will fall.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再次注意文本如何始终对齐4空格缩进（包括上面继续第3项的最后一行）。&lt;/p&gt;
&lt;p&gt;Here&apos;s a link to &lt;a href=&quot;http://foo.bar&quot;&gt;a website&lt;/a&gt;, to a &lt;a href=&quot;local-doc.html&quot;&gt;local
doc&lt;/a&gt;, and to a &lt;a href=&quot;#an-h2-header&quot;&gt;section heading in the current
doc&lt;/a&gt;. Here&apos;s a footnote [^1].&lt;/p&gt;
&lt;p&gt;&lt;code&gt;这是一个指向网站的链接，指向本地文档的链接，以及指向当前文档中章节标题的链接&lt;/code&gt; &lt;code&gt;这是一个脚注&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[^1]: Footnote text goes here.
&lt;code&gt;这是一个脚注&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表格可以看起来像这样:&lt;/p&gt;
&lt;p&gt;(这个用不了 : Fuwari 主题使用的是标准 Markdown 解析器，不直接支持 Pandoc 特有的极简表格语法（如无竖线的表格）,这部分我用代码块括起来，不用看)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;size material color

---

9 leather brown
10 hemp canvas natural
11 glass transparent

Table: Shoes, their sizes, and what they&apos;re made of

(The above is the caption for the table.) Pandoc also supports
multi-line tables:

---

keyword text

---

red Sunsets, apples, and
other red or reddish
things.

green Leaves, grass, frogs
and other things it&apos;s
not easy being.

---

接下来是一条水平分割线。

---

这是一个定义列表：

苹果
: 适合做苹果酱。
橙子
: 柑橘类！
西红柿
: &quot;tomato&quot;中没有&quot;e&quot;。

同样，文本缩进4个空格。（在每个术语/定义对之间放一个空行以使内容更分散。）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准markdown下的表格文档为:&lt;/p&gt;
&lt;h2&gt;基础表格&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;年龄&lt;/th&gt;
&lt;th&gt;职业&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;张三&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;设计师&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;李四&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;开发者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;王五&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;产品经理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;带对齐方式的表格&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;左对齐内容&lt;/th&gt;
&lt;th&gt;居中对齐内容&lt;/th&gt;
&lt;th&gt;右对齐内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文本1&lt;/td&gt;
&lt;td&gt;文本2&lt;/td&gt;
&lt;td&gt;数值1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长文本示例&lt;/td&gt;
&lt;td&gt;居中文本&lt;/td&gt;
&lt;td&gt;12345&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这是一个&quot;行块&quot;：&lt;/p&gt;
&lt;p&gt;| 第一行
| 第二行
| 第三行&lt;/p&gt;
&lt;p&gt;图像可以这样指定：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[//]: # (![example image]&amp;amp;#40;./demo-banner.png &quot;An exemplary image&quot;&amp;amp;#41;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;行内数学方程这样插入：$\omega = d\phi / dt$。显示数学应该独占一行并用双美元符号括起来：&lt;/p&gt;
&lt;p&gt;$$I = \int \rho R^{2} dV$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation*}
\pi
=3.1415926535
;8979323846;2643383279;5028841971;6939937510;5820974944
;5923078164;0628620899;8628034825;3421170679;\ldots
\end{equation*}
$$&lt;/p&gt;
&lt;p&gt;And note that you can backslash-escape any punctuation characters which you wish to be displayed literally, ex.: &lt;code&gt;foo&lt;/code&gt;, &lt;em&gt;bar&lt;/em&gt;, etc.
&lt;code&gt;请注意，您可以用反斜杠转义任何希望按字面显示的标点字符，例如：&lt;/code&gt;foo&lt;code&gt;、*bar*等。&lt;/code&gt;&lt;/p&gt;
</content:encoded></item><item><title>在文章中嵌入视频</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/video/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/video/</guid><description>本文演示如何在博客文章中嵌入视频。</description><pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;只需从 YouTube 或其他平台复制嵌入代码，然后粘贴到 markdown 文件中即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: 在文章中嵌入视频
published: 2023-10-19
// ...
---

&amp;lt;iframe 
    width=&quot;100%&quot; 
    height=&quot;468&quot; 
    src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; 
    title=&quot;YouTube 视频播放器&quot; 
    frameborder=&quot;0&quot; 
    allowfullscreen&amp;gt;
&amp;lt;/iframe&amp;gt;

# 属性有下面这些
# &amp;lt;iframe 
#   width=&quot;100%&quot; 
#   height=&quot;400&quot; 
#   src=&quot;https://www.youtube.com/embed/视频ID&quot; 
#   title=&quot;视频标题&quot;
#   frameborder=&quot;0&quot; 
#   allowfullscreen&amp;gt;
# &amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube 视频播放器&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>LeetcodeProblem-11</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/leetcodeproblem/leetcodeproblem-11/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/leetcodeproblem/leetcodeproblem-11/</guid><description>力扣第11题</description><pubDate>Thu, 25 Jan 1900 00:00:00 GMT</pubDate><content:encoded>&lt;hr /&gt;
&lt;h2&gt;11. 盛最多水的容器&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;height&lt;/code&gt; 。有 &lt;code&gt;n&lt;/code&gt; 条垂线，第 &lt;code&gt;i&lt;/code&gt; 条线的两个端点是 &lt;code&gt;(i, 0)&lt;/code&gt; 和 &lt;code&gt;(i, height[i])&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;找出其中的两条线，使得它们与 &lt;code&gt;x&lt;/code&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;返回容器可以储存的最大水量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 你不能倾斜容器。&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;h4&gt;示例 1&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;./question_11.jpg&quot; alt=&quot;示例图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;[1,8,6,2,5,4,8,3,7]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;49&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;h4&gt;示例 2&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;height = [1,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;提示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == height.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= n &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= height[i] &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;1. 暴力想法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遍历&lt;code&gt;i&lt;/code&gt;作左边界的全部情况&lt;/li&gt;
&lt;li&gt;同时遍历&lt;code&gt;j&lt;/code&gt;作右边界的全部情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间复杂度达到$O(n)$，用时太多，必须考虑其他方法&lt;/p&gt;
&lt;h3&gt;2. 双指针&lt;/h3&gt;
&lt;p&gt;由题目，得到计算储水量的公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设该区间左边界下标为&lt;code&gt;a&lt;/code&gt;，右为&lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那么对应高度值各自为&lt;code&gt;H(a)&lt;/code&gt;,&lt;code&gt;H(b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;总储水量设定特定的&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;的对应值为&lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$f = min(H(a), H(b)) * (b - a)$&lt;/p&gt;
&lt;p&gt;设定两个下标&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;最开始位于左右边界，考虑移动两个下标以获取答案&lt;/p&gt;
&lt;p&gt;答案要求得&lt;code&gt;f_Max&lt;/code&gt;，思考如何移动才可能获得最大的答案&lt;/p&gt;
&lt;p&gt;假设我们每次移动H较大的下标&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if H(a) &amp;gt; H(b) &amp;amp;&amp;amp; move(a)-&amp;gt; :
    {        if(a1增大)
        {
            assert(f减小);
        }else
        {
            assert(f减小)
        }
    }
    else if H(a) &amp;lt; H(b) &amp;amp;&amp;amp; &amp;lt;-move(b):
    {
        同理
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此我们可以看出，想使得&lt;code&gt;f&lt;/code&gt;增大，只可能移动&lt;code&gt;H&lt;/code&gt;较小的对应坐标&lt;/p&gt;
&lt;p&gt;最终得双指针解题思路:&lt;/p&gt;
&lt;p&gt;设定&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;每次移动对应H值较小的哪一个，维护一个&lt;code&gt;ans&lt;/code&gt;值获取移动过程中产生的可能最大值&lt;/p&gt;
&lt;h4&gt;双指针·代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        int a = 0;
        int b = height.size() - 1;
        int ans = 0;
        while(a &amp;lt; b)
        {
            ans = max(ans,(b - a) * min(height[a], height[b]));
            if(height[a] &amp;gt; height[b])
            {
                // a更高，移动b
                b--;          
            }else
            {
                a++;          
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3. 动态规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同理设定&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;,&lt;code&gt;f&lt;/code&gt;
我们先朴素的考虑分解问题，尝试dp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设定&lt;code&gt;dp[i][j]&lt;/code&gt;为:以&lt;code&gt;i&lt;/code&gt;为左边界，&lt;code&gt;j&lt;/code&gt;为右边界所能得到的最大储水值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态转移方程:$$dp[i][j] = max(dp[i+1][j], dp[i][j-1], f)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界条件: &lt;code&gt;if(i == j)return 0;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑优化：不进行滚动数组优化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以发现该做法的时间复杂度极高，实际上比暴力更慢，因为不仅要算出全部的&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;j&lt;/code&gt;区间的对应储水值，还会产生重复计算&lt;/p&gt;
&lt;h4&gt;灵光一现的优化(贪心)&lt;/h4&gt;
&lt;p&gt;实际上和双指针同理发现了，如果移动H较大下标，那么无法得到可能的最大值，于是修改了状态转移方程&lt;/p&gt;
&lt;p&gt;$$if (i &amp;gt; j) : dp[i][j] = max(f, dp[i][j-1]$$&lt;/p&gt;
&lt;p&gt;$$if (i &amp;lt; j) : dp[i][j] = max(f, dp[i+1][j]$$&lt;/p&gt;
&lt;p&gt;实际实现使用递归记录左右边界即可避免开空间复杂度为平方级的数组&lt;/p&gt;
&lt;h4&gt;DP·代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
private:
    int ans = 0;
public:
    int GetAns(vector&amp;lt;int&amp;gt; &amp;amp;height, int x, int y)
    {
        if(x == y)
        {
            return 0;
        }

        ans = max(ans,  min(height[x], height[y]) * (y - x));
        if(height[x] &amp;gt; height[y])
        {
            y--;
        }else
        {
            x++;
        }
        
        ans = max(ans, GetAns(height, x, y));
        return ans;
    }
    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        return GetAns(height, 0, height.size() - 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetcodeProblem-55</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/leetcodeproblem/leetcodeproblem-55/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/leetcodeproblem/leetcodeproblem-55/</guid><description>力扣第55题</description><pubDate>Wed, 24 Jan 1900 00:00:00 GMT</pubDate><content:encoded>&lt;hr /&gt;
&lt;h2&gt;55. 跳跃游戏&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给你一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标，如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;h4&gt;示例 1&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [2,3,1,1,4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。&lt;/p&gt;
&lt;h4&gt;示例 2&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [3,2,1,0,4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。&lt;/p&gt;
&lt;h3&gt;提示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= nums[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;h3&gt;思路一：贪心&lt;/h3&gt;
&lt;p&gt;如果一个位置&lt;code&gt;pos&lt;/code&gt;是可达的,那么从该位置到&lt;code&gt;pos + num[pos]&lt;/code&gt;的位置都是可达的&lt;/p&gt;
&lt;p&gt;考虑维护一个变量&lt;code&gt;Max&lt;/code&gt;,用于记录当遍历数组至某一位置时，最远的可达位置&lt;/p&gt;
&lt;p&gt;遍历数组，每到达一个新的位置&lt;code&gt;i&lt;/code&gt;:
- 若&lt;code&gt;Max &amp;lt; i&lt;/code&gt;,那么&lt;code&gt;return false&lt;/code&gt;
- 更新&lt;code&gt;Max&lt;/code&gt;,&lt;code&gt;Max = max(Max, i + nums[i])&lt;/code&gt;
- 若&lt;code&gt;Max &amp;gt;= nums.length - 1&lt;/code&gt;(下标从0开始),那么&lt;code&gt;return true&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;时间复杂度&lt;/h4&gt;
&lt;p&gt;$$O(N)$$&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int Max = 0;
        for(int i = 0; i &amp;lt; nums.size(); i++){
            if(Max &amp;lt; i)return false;
            Max = max(Max, i + nums[i]);
            if(Max &amp;gt;= nums.size() - 1)return true;
        }
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;思路二：动态规划&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;考虑一个一维数组&lt;code&gt;dp&lt;/code&gt;，遍历数组到某一位置&lt;code&gt;i&lt;/code&gt;时,&lt;code&gt;dp[i]&lt;/code&gt;的定义为&lt;code&gt;在位置i能走的最大步数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计&lt;code&gt;dp&lt;/code&gt;数组的状态转移方程，遍历数组，当前位置的&lt;code&gt;dp[i]&lt;/code&gt;为&lt;code&gt;dp[i-1]再走一步的剩余步数&lt;/code&gt;和&lt;code&gt;nums[i]&lt;/code&gt;中的最大值，那么有状态转移方程&lt;code&gt;dp[i] = max(dp[i-1] - 1, nums[i])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界条件(初始化)：&lt;code&gt;dp[0] = nums[0]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历数组，到新位置即进行状态转移，更新&lt;code&gt;dp[i]&lt;/code&gt;,之后判断&lt;code&gt;dp[i]&lt;/code&gt;是否为0，是，则无法前进了，&lt;code&gt;return false&lt;/code&gt;,不是则继续遍历，若最终退出了遍历循环，那么说明角色可以到达终点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑优化：当前状态之和上一次的状态有关，可以使用滚动变量进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;时间复杂度&lt;/h4&gt;
&lt;p&gt;$$O(N)$$&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int dp = -1;// 第1步的上一步不存在，初始化为-1
        for(int i = 0; i &amp;lt; nums.size(); i++)
        {
            if(!dp)return false;
            dp = max(dp - 1, nums[i]); 
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::caution[注意]
&lt;strong&gt;dp判0的语句必须放置在状态更新的语句之后:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;i = nums.size()-1&lt;/code&gt;时，若&lt;code&gt;nums[i] = 0&lt;/code&gt;并且&lt;code&gt;dp = 1&lt;/code&gt;,状态更新之后,在最后一个位置能走的最大步数为0，&lt;code&gt;return false&lt;/code&gt;,但是此时我们已经到终点,于是结果出错
:::&lt;/p&gt;
&lt;p&gt;:::note[关于此动态规划]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个题解思路展示了动态规划问题的关键解题元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动规数组/变量定义&lt;/li&gt;
&lt;li&gt;状态转移方程&lt;/li&gt;
&lt;li&gt;边界条件(初始化)&lt;/li&gt;
&lt;li&gt;考虑优化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;DFS的错误&lt;/h3&gt;
&lt;h4&gt;爆搜思路&lt;/h4&gt;
&lt;p&gt;由于此题的数量级为1e4,数据较小，那么尝试从起点开始搜索，尝试去到距离起点最远可达处x，再从x的最远可达处进行尝试，最终看能否到达终点，这样依次尝试至最靠近起点的位置，即可求得答案&lt;/p&gt;
&lt;h4&gt;时间复杂度&lt;/h4&gt;
&lt;p&gt;当数组呈现&lt;code&gt;{n}、{n-1}……、{2}、{1}、{0}、{0}&lt;/code&gt;的模样时，时间复杂度将达到$O(n!)$&lt;/p&gt;
&lt;p&gt;:::tip[e.g.]
如5、4、3、2、1、0、0&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从起点&lt;code&gt;5&lt;/code&gt;出发，到&lt;code&gt;0&lt;/code&gt;,无法前进&lt;/li&gt;
&lt;li&gt;退一步，到达&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;前进一步到达&lt;code&gt;0&lt;/code&gt;,无法前进&lt;/li&gt;
&lt;li&gt;退一步，到达&lt;code&gt;2&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;前进两步到达&lt;code&gt;0&lt;/code&gt;,无法前进,……以此类推
对于&lt;code&gt;5&lt;/code&gt;,它会使得角色到&lt;code&gt;4&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt;
对于&lt;code&gt;4&lt;/code&gt;,它会使得角色到&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;以此类推&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
</content:encoded></item></channel></rss>