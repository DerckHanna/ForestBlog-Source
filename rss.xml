<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Forest</title><description>Code and Grow</description><link>https://derckhanna.github.io/ForestBlog-Source/</link><language>zh_CN</language><item><title>Average Case Time Complexity</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/others/average-case-time-complexity/average_case_time_complexity/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/others/average-case-time-complexity/average_case_time_complexity/</guid><description>平均时间复杂度分析计算</description><pubDate>Sat, 04 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面来源: &lt;a href=&quot;https://dimtown.com/84456.html&quot;&gt;次元小镇&lt;/a&gt;
画师：日本插画师Uom&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;平均时间复杂度的定义&lt;/h2&gt;
&lt;p&gt;平均情况时间复杂度 = 所有&lt;code&gt;可能输入的时间复杂度&lt;/code&gt;的&lt;strong&gt;期望值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;期望值：在概率论和统计学中，期望值（或数学期望、或均值，亦简称期望，物理学中称为期待值）是指在一个离散性随机变量试验中&lt;code&gt;每次可能结果的概率乘以其结果的总和&lt;/code&gt;。(来自：&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%9F%E6%9C%9B%E5%80%BC/8664642&quot;&gt;百度百科-期望值&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;平均时间复杂度计算&lt;/h2&gt;
&lt;h3&gt;基本公式&lt;/h3&gt;
&lt;p&gt;平均时间复杂度的数学期望为：&lt;/p&gt;
&lt;p&gt;$$E(T) = \sum_{i=1}^{n} P(i) \cdot T(i)$$&lt;/p&gt;
&lt;h4&gt;变量说明&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;$E(T)$：期望运行时间复杂度&lt;/li&gt;
&lt;li&gt;$P(i)$：第 $i$ 种输入情况的概率&lt;/li&gt;
&lt;li&gt;$T(i)$：第 $i$ 种输入情况的执行时间&lt;/li&gt;
&lt;li&gt;$n$：所有可能的输入情况总数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;线性查找实例&lt;/h2&gt;
&lt;p&gt;对于线性查找算法：&lt;/p&gt;
&lt;p&gt;以查找不含重复元素的&lt;code&gt;vector&amp;lt;int&amp;gt; a&lt;/code&gt;中的某个元素为例，如果找到了，则返回对应元素的索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int Find_(int p)
{
    for(int i = 0; i &amp;lt; a.size(); i++)
    {
        if(a[i] == p){
            return i;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设数组中有&lt;code&gt;n&lt;/code&gt;个元素，需要查找的元素出现在数组每个位置的几率相等且和不出现在数组中的概率相等&lt;/p&gt;
&lt;p&gt;那么有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素出现在第一个位置的概率为 $1 / (n + 1)$&lt;/li&gt;
&lt;li&gt;元素出现在第二个位置的概率为 $1 / (n + 1)$&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;li&gt;元素出现在第n个位置的概率为 $1 / (n + 1)$&lt;/li&gt;
&lt;li&gt;元素没有在数组中的概率为 $1 / (n + 1)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$E(T)$$&lt;/p&gt;
&lt;p&gt;$$= 1 \cdot 1 / (n + 1) + 2 \cdot  1 / (n + 1) + …… + n \cdot  1 / (n + 1) + n \cdot  1 / (n + 1)$$&lt;/p&gt;
&lt;p&gt;$$= \sum_{i=1}^{n} \frac{i}{n+1} + \frac{n}{n+1}$$&lt;/p&gt;
&lt;p&gt;$$= \frac{n(n + 3)}{2(n + 1)}$$&lt;/p&gt;
&lt;p&gt;实际计算时可忽略常数，只看数量级&lt;/p&gt;
&lt;p&gt;从结果来看，$E(T)$等同于$O(n)$&lt;/p&gt;
</content:encoded></item><item><title>C++|起始终末函数们的区别</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/c-in-depth/from_inception_to_demise/from_inception_to_demise/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/c-in-depth/from_inception_to_demise/from_inception_to_demise/</guid><description>区分begin-begin、cbegin-cend、front-back,并进行纵向对比</description><pubDate>Mon, 29 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面来源: &lt;a href=&quot;https://dimtown.com/50821.html&quot;&gt;次元小镇&lt;/a&gt;
画师：日本插画师みふる&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;起始终末函数们&lt;/h2&gt;
&lt;p&gt;本文讨论的函数为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;begin()&lt;/code&gt;和&lt;code&gt;end()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cbegin()&lt;/code&gt;和&lt;code&gt;cend()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;front()&lt;/code&gt;和&lt;code&gt;back&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;区别辨析&lt;/h2&gt;
&lt;h3&gt;&lt;code&gt;begin()&lt;/code&gt;与&lt;code&gt;end()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;begin()&lt;/code&gt;将返回容器的首位元素的迭代器，当容器为空时，作用等同于end&lt;/li&gt;
&lt;li&gt;&lt;code&gt;end()&lt;/code&gt;将返回容器末尾后面一个位置的迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::tip[Tips:]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回的是&lt;code&gt;迭代器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当容器为空时依然可以正常使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;cbegin()&lt;/code&gt;与&lt;code&gt;cend()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这二者是&lt;strong&gt;C++11&lt;/strong&gt;引入的函数，基本功能与&lt;code&gt;begin()&lt;/code&gt;和&lt;code&gt;end()&lt;/code&gt;并无差别，不过这二者返回的是&lt;code&gt;常量位置迭代器&lt;/code&gt;，不允许通过迭代器修改容器内元素，避免意外修改&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;front()&lt;/code&gt;与&lt;code&gt;back()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;front()&lt;/code&gt;返回的是容器&lt;strong&gt;第一个位置&lt;/strong&gt;的&lt;strong&gt;引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;back()&lt;/code&gt;返回的是容器&lt;strong&gt;最后一个位置&lt;/strong&gt;的&lt;strong&gt;引用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::tip[Tips:]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回的是&lt;code&gt;引用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当容器为空时使用，会造成未定义行为(UH)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;适用容器&lt;/th&gt;
&lt;th&gt;空容器行为&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cbegin()&lt;/td&gt;
&lt;td&gt;const_iterator&lt;/td&gt;
&lt;td&gt;获取指向第一个元素的迭代器&lt;/td&gt;
&lt;td&gt;所有STL容器&lt;/td&gt;
&lt;td&gt;与 cend() 相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cend()&lt;/td&gt;
&lt;td&gt;const_iterator&lt;/td&gt;
&lt;td&gt;获取指向尾后位置的迭代器&lt;/td&gt;
&lt;td&gt;所有STL容器&lt;/td&gt;
&lt;td&gt;获取指向尾后位置的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;begin()&lt;/td&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;获取指向第一个元素的迭代器&lt;/td&gt;
&lt;td&gt;所有STL容器&lt;/td&gt;
&lt;td&gt;与 end() 相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;end()&lt;/td&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;获取指向尾后位置的迭代器&lt;/td&gt;
&lt;td&gt;所有STL容器&lt;/td&gt;
&lt;td&gt;获取指向尾后位置的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;front()&lt;/td&gt;
&lt;td&gt;元素引用&lt;/td&gt;
&lt;td&gt;直接访问首元素&lt;/td&gt;
&lt;td&gt;vector, deque, list, forward_list&lt;/td&gt;
&lt;td&gt;未定义行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;back()&lt;/td&gt;
&lt;td&gt;元素引用&lt;/td&gt;
&lt;td&gt;直接访问尾元素&lt;/td&gt;
&lt;td&gt;vector, deque, list&lt;/td&gt;
&lt;td&gt;未定义行为&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content:encoded></item><item><title>PostsGuide</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/postsguide/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/postsguide/</guid><description>个人博客文章分类指南</description><pubDate>Fri, 26 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;博客文章分类指南&lt;/h1&gt;
&lt;h2&gt;命名规范&lt;/h2&gt;
&lt;h3&gt;文件夹命名&lt;/h3&gt;
&lt;p&gt;首字母大写单词 + 空格&lt;/p&gt;
&lt;p&gt;&lt;code&gt;e.g. Blog Guild&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;文件命名&lt;/h3&gt;
&lt;h3&gt;命名规则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全部小写&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用连字符分隔单词&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保持描述性但简洁&lt;/strong&gt; (3-5个关键词)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包含主要技术关键词&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免使用日期&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;标签使用原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每个文章3-5个标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从具体到一般&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免过于宽泛的标签&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>C++|指针_and_引用</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/c-in-depth/pointer__reference/pointer__reference/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/c-in-depth/pointer__reference/pointer__reference/</guid><description>快速明晰指针和引用，顺便区分(&amp;)(*)(-&gt;)</description><pubDate>Mon, 22 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面来源: &lt;a href=&quot;https://dimtown.com/50821.html&quot;&gt;次元小镇&lt;/a&gt;
画师：日本插画师みふる&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;指针与引用&lt;/h2&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;引用不是变量，不占用储存空间，由编译器实现。引用是给变量取的别名，它必须初始化且初始化之后无法改变其指定的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 100;
int&amp;amp; ref = a; // 一个名为ref的int类型的引用的声明，必须初始化，它现在是a的别名
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;指针&lt;/h3&gt;
&lt;p&gt;指针是一种变量,也是用于储存值的，而指针所储存的为地址，指针需要指明指针类型，用于表明其指向变量的类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int* ptr; // 一个名为ptr的int类型指针的声明
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;空指针&lt;/h3&gt;
&lt;p&gt;空指针有很两种，&lt;code&gt;NULL&lt;/code&gt;(&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;(char*) 0&lt;/code&gt;)、&lt;code&gt;nullptr&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;NULL&lt;/code&gt;空指针&lt;/h4&gt;
&lt;p&gt;NULL是一种定义宏，通常就是&lt;code&gt;0&lt;/code&gt;(或者是(void*)0,但是这种情况极少，一般是C语言的用法，取决于编译器)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define NULL 0
// 或
#define NULL (void*) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::tip[宏]
宏可以简单理解为“取别名”,它在编译前的预处理中被执行，将别名全部替换为指定文本
:::&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NULL的本质是&lt;code&gt;(int) 0&lt;/code&gt;，是整型而不是一个指针，这实际上就会导致一些问题&lt;/p&gt;
&lt;p&gt;NULL重载函数二义性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;

void function(int input)
{
    cout &amp;lt;&amp;lt; &quot;The input is of int type&quot; &amp;lt;&amp;lt; endl;
    return;
}

void function(int* input)
{
    cout &amp;lt;&amp;lt; &quot;The input is of int* type&quot; &amp;lt;&amp;lt; endl;
    return;
}

int main()
{
    function(NULL);  // 从从 NULL 转换为非指针类型“int”[-Wconversion-null]
    return 0;    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么其实你可以猜测会输出什么——输出了：“The input is of int type”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(void* 0)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显式定义了指针，但是依然能导致重载错误等错误，不再讨论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nullptr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11后引入的特性,现代空指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nullptr&lt;/code&gt;的类型是&lt;code&gt;std::nullptr_t&lt;/code&gt;,并不是定义宏，这个类型可以隐式转换为任何其他指针类型&lt;/p&gt;
&lt;p&gt;在C++11之后，任何的空指针都应该这样写，现代而安全&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;

void function(int input)
{
    cout &amp;lt;&amp;lt; &quot;The input is of int type&quot; &amp;lt;&amp;lt; endl;
    return;
}

void function(int* input)
{
    cout &amp;lt;&amp;lt; &quot;The input is of int* type&quot; &amp;lt;&amp;lt; endl;
    return;
}

int main()
{
    function(nullptr);
    return 0;    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在将输出:“The input is of int* type”&lt;/p&gt;
&lt;h2&gt;指针与引用相关的运算符&lt;/h2&gt;
&lt;h3&gt;运算符**&amp;amp;**：&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;取地址运算符&lt;/p&gt;
&lt;p&gt;作用：顾名思义，获取变量在内存中的地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 100;
int* p = &amp;amp;a; // 现在指针p中储存的是a的地址,&amp;amp;a的作用就是获取a的地址
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;运算符&lt;strong&gt;Star&lt;/strong&gt;: &lt;code&gt;*&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;解引用运算符&lt;/p&gt;
&lt;p&gt;作用：通过指针访问或修改该指针所指向的内存地址中存储的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n = 100;
int* ptr = &amp;amp;n; // 声明指针ptr
*ptr = 10;     // 通过解引用指针修改n,现在n = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;运算符&lt;strong&gt;arrows&lt;/strong&gt;：&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于通过指针访问结构体或类成员。它等价于指针先解引用，再加上&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为什么需要此运算符？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为解引用运算符&lt;code&gt;*&lt;/code&gt;的优先级比点号运算符&lt;code&gt;.&lt;/code&gt;高，如果要用它们，那么会写为&lt;code&gt;(*pointer).member&lt;/code&gt;,不够简洁&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;

struct Node
{
    int x;
    int y;
}node;

int main()
{
    node.x = 1;
    node.y = 2;    
    Node* ptr = &amp;amp;node;
    
    cout &amp;lt;&amp;lt; ptr-&amp;gt;x &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; ptr-&amp;gt;y &amp;lt;&amp;lt; endl;
    return 0;    
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Traversal of data structures</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/data-structures--algorithms/other-categories/traversal-of-data-structures/traversal-of-data-structures/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/data-structures--algorithms/other-categories/traversal-of-data-structures/traversal-of-data-structures/</guid><description>数据结构遍历的各种写法</description><pubDate>Sun, 21 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面来源: &lt;a href=&quot;https://dimtown.com/50821.html&quot;&gt;次元小镇&lt;/a&gt;
画师：日本插画师みふる&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;数据结构的遍历&lt;/h2&gt;
</content:encoded></item><item><title>LeetcodeProblem-11</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/data-structures--algorithms/practical-problem-solving/lc-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/leetcodeproblem-11/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/data-structures--algorithms/practical-problem-solving/lc-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/leetcodeproblem-11/</guid><description>力扣第11题个人题解</description><pubDate>Fri, 12 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面：Leetcode Logo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;11. 盛最多水的容器&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;height&lt;/code&gt; 。有 &lt;code&gt;n&lt;/code&gt; 条垂线，第 &lt;code&gt;i&lt;/code&gt; 条线的两个端点是 &lt;code&gt;(i, 0)&lt;/code&gt; 和 &lt;code&gt;(i, height[i])&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;找出其中的两条线，使得它们与 &lt;code&gt;x&lt;/code&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;返回容器可以储存的最大水量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 你不能倾斜容器。&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;h4&gt;示例 1&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;./question_11.jpg&quot; alt=&quot;示例图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;[1,8,6,2,5,4,8,3,7]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;49&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;h4&gt;示例 2&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;height = [1,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;提示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == height.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= n &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= height[i] &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;1. 暴力想法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遍历&lt;code&gt;i&lt;/code&gt;作左边界的全部情况&lt;/li&gt;
&lt;li&gt;同时遍历&lt;code&gt;j&lt;/code&gt;作右边界的全部情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间复杂度达到$O(n)$，用时太多，必须考虑其他方法&lt;/p&gt;
&lt;h3&gt;2. 双指针&lt;/h3&gt;
&lt;p&gt;由题目，得到计算储水量的公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设该区间左边界下标为&lt;code&gt;a&lt;/code&gt;，右为&lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那么对应高度值各自为&lt;code&gt;H(a)&lt;/code&gt;,&lt;code&gt;H(b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;总储水量设定特定的&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;的对应值为&lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$f = min(H(a), H(b)) * (b - a)$&lt;/p&gt;
&lt;p&gt;设定两个下标&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;最开始位于左右边界，考虑移动两个下标以获取答案&lt;/p&gt;
&lt;p&gt;答案要求得&lt;code&gt;f_Max&lt;/code&gt;，思考如何移动才可能获得最大的答案&lt;/p&gt;
&lt;p&gt;假设我们每次移动H较大的下标&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if H(a) &amp;gt; H(b) &amp;amp;&amp;amp; move(a)-&amp;gt; :
    {        if(a1增大)
        {
            assert(f减小);
        }else
        {
            assert(f减小)
        }
    }
    else if H(a) &amp;lt; H(b) &amp;amp;&amp;amp; &amp;lt;-move(b):
    {
        同理
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此我们可以看出，想使得&lt;code&gt;f&lt;/code&gt;增大，只可能移动&lt;code&gt;H&lt;/code&gt;较小的对应坐标&lt;/p&gt;
&lt;p&gt;最终得双指针解题思路:&lt;/p&gt;
&lt;p&gt;设定&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;每次移动对应H值较小的哪一个，维护一个&lt;code&gt;ans&lt;/code&gt;值获取移动过程中产生的可能最大值&lt;/p&gt;
&lt;h4&gt;双指针·代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        int a = 0;
        int b = height.size() - 1;
        int ans = 0;
        while(a &amp;lt; b)
        {
            ans = max(ans,(b - a) * min(height[a], height[b]));
            if(height[a] &amp;gt; height[b])
            {
                // a更高，移动b
                b--;          
            }else
            {
                a++;          
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3. 动态规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同理设定&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;,&lt;code&gt;f&lt;/code&gt;
我们先朴素的考虑分解问题，尝试dp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设定&lt;code&gt;dp[i][j]&lt;/code&gt;为:以&lt;code&gt;i&lt;/code&gt;为左边界，&lt;code&gt;j&lt;/code&gt;为右边界所能得到的最大储水值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态转移方程:$$dp[i][j] = max(dp[i+1][j], dp[i][j-1], f)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界条件: &lt;code&gt;if(i == j)return 0;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑优化：不进行滚动数组优化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以发现该做法的时间复杂度极高，实际上比暴力更慢，因为不仅要算出全部的&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;j&lt;/code&gt;区间的对应储水值，还会产生重复计算&lt;/p&gt;
&lt;h4&gt;灵光一现的优化(贪心)&lt;/h4&gt;
&lt;p&gt;实际上和双指针同理发现了，如果移动H较大下标，那么无法得到可能的最大值，于是修改了状态转移方程&lt;/p&gt;
&lt;p&gt;$$if (i &amp;gt; j) : dp[i][j] = max(f, dp[i][j-1]$$&lt;/p&gt;
&lt;p&gt;$$if (i &amp;lt; j) : dp[i][j] = max(f, dp[i+1][j]$$&lt;/p&gt;
&lt;p&gt;实际实现使用递归记录左右边界即可避免开空间复杂度为平方级的数组&lt;/p&gt;
&lt;h4&gt;DP·代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
private:
    int ans = 0;
public:
    int GetAns(vector&amp;lt;int&amp;gt; &amp;amp;height, int x, int y)
    {
        if(x == y)
        {
            return 0;
        }

        ans = max(ans,  min(height[x], height[y]) * (y - x));
        if(height[x] &amp;gt; height[y])
        {
            y--;
        }else
        {
            x++;
        }
        
        ans = max(ans, GetAns(height, x, y));
        return ans;
    }
    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        return GetAns(height, 0, height.size() - 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetcodeProblem-55</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/data-structures--algorithms/practical-problem-solving/lc-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/leetcodeproblem-55/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/data-structures--algorithms/practical-problem-solving/lc-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/leetcodeproblem-55/</guid><description>力扣第55题个人题解</description><pubDate>Wed, 10 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面：Leetcode Logo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;55. 跳跃游戏&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给你一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标，如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;h4&gt;示例 1&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [2,3,1,1,4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。&lt;/p&gt;
&lt;h4&gt;示例 2&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [3,2,1,0,4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。&lt;/p&gt;
&lt;h3&gt;提示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= nums[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;h3&gt;思路一：贪心&lt;/h3&gt;
&lt;p&gt;如果一个位置&lt;code&gt;pos&lt;/code&gt;是可达的,那么从该位置到&lt;code&gt;pos + num[pos]&lt;/code&gt;的位置都是可达的&lt;/p&gt;
&lt;p&gt;考虑维护一个变量&lt;code&gt;Max&lt;/code&gt;,用于记录当遍历数组至某一位置时，最远的可达位置&lt;/p&gt;
&lt;p&gt;遍历数组，每到达一个新的位置&lt;code&gt;i&lt;/code&gt;:
- 若&lt;code&gt;Max &amp;lt; i&lt;/code&gt;,那么&lt;code&gt;return false&lt;/code&gt;
- 更新&lt;code&gt;Max&lt;/code&gt;,&lt;code&gt;Max = max(Max, i + nums[i])&lt;/code&gt;
- 若&lt;code&gt;Max &amp;gt;= nums.length - 1&lt;/code&gt;(下标从0开始),那么&lt;code&gt;return true&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;时间复杂度&lt;/h4&gt;
&lt;p&gt;$$O(N)$$&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int Max = 0;
        for(int i = 0; i &amp;lt; nums.size(); i++){
            if(Max &amp;lt; i)return false;
            Max = max(Max, i + nums[i]);
            if(Max &amp;gt;= nums.size() - 1)return true;
        }
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;思路二：动态规划&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;考虑一个一维数组&lt;code&gt;dp&lt;/code&gt;，遍历数组到某一位置&lt;code&gt;i&lt;/code&gt;时,&lt;code&gt;dp[i]&lt;/code&gt;的定义为&lt;code&gt;在位置i能走的最大步数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计&lt;code&gt;dp&lt;/code&gt;数组的状态转移方程，遍历数组，当前位置的&lt;code&gt;dp[i]&lt;/code&gt;为&lt;code&gt;dp[i-1]再走一步的剩余步数&lt;/code&gt;和&lt;code&gt;nums[i]&lt;/code&gt;中的最大值，那么有状态转移方程&lt;code&gt;dp[i] = max(dp[i-1] - 1, nums[i])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界条件(初始化)：&lt;code&gt;dp[0] = nums[0]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历数组，到新位置即进行状态转移，更新&lt;code&gt;dp[i]&lt;/code&gt;,之后判断&lt;code&gt;dp[i]&lt;/code&gt;是否为0，是，则无法前进了，&lt;code&gt;return false&lt;/code&gt;,不是则继续遍历，若最终退出了遍历循环，那么说明角色可以到达终点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑优化：当前状态之和上一次的状态有关，可以使用滚动变量进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;时间复杂度&lt;/h4&gt;
&lt;p&gt;$$O(N)$$&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int dp = -1;// 第1步的上一步不存在，初始化为-1
        for(int i = 0; i &amp;lt; nums.size(); i++)
        {
            if(!dp)return false;
            dp = max(dp - 1, nums[i]); 
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::caution[注意]
&lt;strong&gt;dp判0的语句必须放置在状态更新的语句之后:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;i = nums.size()-1&lt;/code&gt;时，若&lt;code&gt;nums[i] = 0&lt;/code&gt;并且&lt;code&gt;dp = 1&lt;/code&gt;,状态更新之后,在最后一个位置能走的最大步数为0，&lt;code&gt;return false&lt;/code&gt;,但是此时我们已经到终点,于是结果出错
:::&lt;/p&gt;
&lt;p&gt;:::note[关于此动态规划]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个题解思路展示了动态规划问题的关键解题元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动规数组/变量定义&lt;/li&gt;
&lt;li&gt;状态转移方程&lt;/li&gt;
&lt;li&gt;边界条件(初始化)&lt;/li&gt;
&lt;li&gt;考虑优化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;DFS的错误&lt;/h3&gt;
&lt;h4&gt;爆搜思路&lt;/h4&gt;
&lt;p&gt;由于此题的数量级为1e4,数据较小，那么尝试从起点开始搜索，尝试去到距离起点最远可达处x，再从x的最远可达处进行尝试，最终看能否到达终点，这样依次尝试至最靠近起点的位置，即可求得答案&lt;/p&gt;
&lt;h4&gt;时间复杂度&lt;/h4&gt;
&lt;p&gt;当数组呈现&lt;code&gt;{n}、{n-1}……、{2}、{1}、{0}、{0}&lt;/code&gt;的模样时，时间复杂度将达到$O(n!)$&lt;/p&gt;
&lt;p&gt;:::tip[e.g.]
如5、4、3、2、1、0、0&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从起点&lt;code&gt;5&lt;/code&gt;出发，到&lt;code&gt;0&lt;/code&gt;,无法前进&lt;/li&gt;
&lt;li&gt;退一步，到达&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;前进一步到达&lt;code&gt;0&lt;/code&gt;,无法前进&lt;/li&gt;
&lt;li&gt;退一步，到达&lt;code&gt;2&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;前进两步到达&lt;code&gt;0&lt;/code&gt;,无法前进,……以此类推
对于&lt;code&gt;5&lt;/code&gt;,它会使得角色到&lt;code&gt;4&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt;
对于&lt;code&gt;4&lt;/code&gt;,它会使得角色到&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;以此类推&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
</content:encoded></item><item><title>meta-learning-model</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/study-methods/meta-learning-model/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/study-methods/meta-learning-model/</guid><pubDate>Mon, 01 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;&quot;元学习&quot;模型&lt;/h1&gt;
&lt;p&gt;元学习的目的便是 &lt;strong&gt;“学会如何学习”&lt;/strong&gt;，回答下面的问题，构建一个高效、自适应、可持续的个人学习系统(针对学习规划中的某一学习内容)&lt;/p&gt;
&lt;h2&gt;--- 学习前解决↓---&lt;/h2&gt;
&lt;h2&gt;一、明确学习动机与目标&lt;/h2&gt;
&lt;p&gt;元学习的起点 —— 先明确 “学习的价值锚点”，避免盲目跟风&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我学习这个的&lt;strong&gt;核心动机&lt;/strong&gt;是什么？&lt;/li&gt;
&lt;li&gt;这个学习目标和我的&lt;strong&gt;长期规划 / 当下需求&lt;/strong&gt;是否匹配？&lt;/li&gt;
&lt;li&gt;我需要学到 “什么程度” 才算 “学会”？&lt;/li&gt;
&lt;li&gt;这个目标是否需要&lt;strong&gt;拆解&lt;/strong&gt;？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;二、学习方法与策略&lt;/h2&gt;
&lt;p&gt;元学习的核心环节 —— 避免 “用低效方法硬熬”&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我当前(准备)用的学习方法，&lt;strong&gt;能高效达到目标吗&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;这个领域有没有 “更适配的经典学习策略”？&lt;/li&gt;
&lt;li&gt;我需要先补哪些 &lt;strong&gt;“基础能力”&lt;/strong&gt;，才能避免卡壳？&lt;/li&gt;
&lt;li&gt;遇到 “学不会的难点” 时，我是该“死磕” 还是 “换思路”？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;--- 学习后解决↓---&lt;/h2&gt;
&lt;h2&gt;三、学习过程监控&lt;/h2&gt;
&lt;p&gt;元学习的 “实时校准环节”—— 避免 “学了一半才发现方向偏了” 或 “进度失控”。核心是 “动态追踪学习状态，及时修正偏差”。&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我每天 / 每周的学习进度，是否符合之前的计划？&lt;/li&gt;
&lt;li&gt;学习时我是否容易分心？(用物理量化,不要用抽象词概括)&lt;/li&gt;
&lt;li&gt;学完一个章节后，我能 “立刻回忆起核心内容” 吗？(若合上书就忘，说明 “输入时没主动思考”)&lt;/li&gt;
&lt;li&gt;这个阶段的学习，让我 “有成就感” 还是 “焦虑”？（若持续焦虑，可能是目标定太高或方法不对，需降低短期目标或换更简单的入门内容）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;四、学习结果评估&lt;/h2&gt;
&lt;p&gt;元学习的 “效果验证环节”—— 避免 “自我感觉学会了，实际不会用”。核心是 “用‘输出’或‘解决问题’验证学习效果”，而非 “看了多少课、记了多少笔记”。&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我能通过 “&lt;strong&gt;输出&lt;/strong&gt;” 证明自己学会了吗？&lt;/li&gt;
&lt;li&gt;这个知识 / 技能，我能 “和已有的知识联系起来” 吗？&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;用 1-10 分打分&lt;/strong&gt;，我对这个知识 / 技能的掌握程度是多少？分数低的原因是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;五、学习迭代优化&lt;/h2&gt;
&lt;p&gt;元学习的 “循环升级环节”—— 让每次学习都成为 “下一次学习的经验”，避免 “重复踩同一个坑”。核心是 “总结本次学习的经验教训，优化下一次的学习策略”。&lt;/p&gt;
&lt;p&gt;:::note[回答提问]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这次学习中，哪些做法 “有效”，下次可以保留？&lt;/li&gt;
&lt;li&gt;哪些做法 “无效”，下次需要改掉？&lt;/li&gt;
&lt;li&gt;如果重新学一遍，我会 “调整哪些环节”？&lt;/li&gt;
&lt;li&gt;这次学习，我的 “学习能力”（比如专注力、理解力、复盘能力）有没有提升？怎么提升的？（比如通过 “每天复盘”，发现自己的 “问题分析能力” 变强了）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
</content:encoded></item><item><title>Markdown 扩展功能</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/markdown-extended/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/markdown-extended/</guid><description>了解更多关于 Fuwari 中的 Markdown 功能</description><pubDate>Wed, 01 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;GitHub 仓库卡片&lt;/h2&gt;
&lt;p&gt;您可以添加动态卡片链接到 GitHub 仓库，页面加载时，仓库信息会从 GitHub API 获取。&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;Fabrizz/MMM-OnSpotify&quot;}&lt;/p&gt;
&lt;p&gt;使用代码 &lt;code&gt;::github{repo=&quot;&amp;lt;所有者&amp;gt;/&amp;lt;仓库名&amp;gt;&quot;}&lt;/code&gt; 创建 GitHub 仓库卡片。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::github{repo=&quot;saicaca/fuwari&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;警示框 (Admonitions)&lt;/h2&gt;
&lt;p&gt;支持以下类型的警示框: &lt;code&gt;note(备注)&lt;/code&gt; &lt;code&gt;tip(提示)&lt;/code&gt; &lt;code&gt;important(重要)&lt;/code&gt; &lt;code&gt;warning(警告)&lt;/code&gt; &lt;code&gt;caution(注意)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;:::note
突出显示用户应该注意的信息，即使在快速浏览时也是如此。
:::&lt;/p&gt;
&lt;p&gt;:::tip
辅助用户更好行动的可选信息。
:::&lt;/p&gt;
&lt;p&gt;:::important
用户所需的关键信息。
:::&lt;/p&gt;
&lt;p&gt;:::warning
由于潜在风险而需要用户立即关注的关键内容。
:::&lt;/p&gt;
&lt;p&gt;:::caution
某个行动可能带来的负面后果。
:::&lt;/p&gt;
&lt;h3&gt;基本语法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;:::note
Highlights information that users should take into account, even when skimming.
:::

:::tip
Optional information to help a user be more successful.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义标题&lt;/h3&gt;
&lt;p&gt;可以自定义警示框的标题。&lt;/p&gt;
&lt;p&gt;:::note[我的自定义标题]
这是一个带有自定义标题的备注。
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;GitHub 语法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
&lt;a href=&quot;https://github.com/orgs/community/discussions/16925&quot;&gt;GitHub 语法&lt;/a&gt; 也受支持.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [!NOTE]
&amp;gt; GitHub 语法也受支持。

&amp;gt; [!TIP]
&amp;gt; GitHub 语法也受支持。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;隐藏内容 (Spoiler)&lt;/h3&gt;
&lt;p&gt;您可以在文本中添加隐藏内容。该内容也支持 &lt;strong&gt;Markdown&lt;/strong&gt; 语法.&lt;/p&gt;
&lt;p&gt;这个内容 : spoiler [ 是隐藏的 &lt;strong&gt;哈哈&lt;/strong&gt; ] !&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
The content : spoiler[is hidden **ayyy**]!
// 孩子们，这个功能似乎用不了

&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Expressive Code 代码展示示例</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/expressive-code/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/expressive-code/</guid><description>使用 Expressive Code 在 Markdown 中展示代码块的效果</description><pubDate>Wed, 10 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在这里，我们将探索使用 &lt;a href=&quot;https://expressive-code.com/&quot;&gt;Expressive Code&lt;/a&gt; 的代码块显示效果。提供的示例基于官方文档，您可以参考获取更多详细信息。&lt;/p&gt;
&lt;h2&gt;Expressive Code 功能&lt;/h2&gt;
&lt;h3&gt;语法高亮&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/syntax-highlighting/&quot;&gt;语法高亮&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;常规语法高亮&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;这段代码有语法高亮效果!&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;渲染 ANSI 转义序列&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ANSI 颜色：
- 常规：[31m红色[0m [32m绿色[0m [33m黄色[0m [34m蓝色[0m [35m洋红色[0m [36m青色[0m
- 粗体：[1;31m红色[0m [1;32m绿色[0m [1;33m黄色[0m [1;34m蓝色[0m [1;35m洋红色[0m [1;36m青色[0m
- 暗淡：[2;31m红色[0m [2;32m绿色[0m [2;33m黄色[0m [2;34m蓝色[0m [2;35m洋红色[0m [2;36m青色[0m

256 色（显示颜色 160-177）：
[38;5;160m160 [38;5;161m161 [38;5;162m162 [38;5;163m163 [38;5;164m164 [38;5;165m165[0m
[38;5;166m166 [38;5;167m167 [38;5;168m168 [38;5;169m169 [38;5;170m170 [38;5;171m171[0m
[38;5;172m172 [38;5;173m173 [38;5;174m174 [38;5;175m175 [38;5;176m176 [38;5;177m177[0m

全 RGB 颜色：
[38;2;34;139;34m森林绿 - RGB(34, 139, 34)[0m

文本格式：[1m粗体[0m [2m暗淡[0m [3m斜体[0m [4m下划线[0m

格式是: [ 配置 内容  [ 0m
[3m实际使用的时候将上面的文本连在一起[0m
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;编辑器与终端框架&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/frames/&quot;&gt;编辑器与终端框架&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;代码编辑器框架&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;标题属性示例&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- src/content/index.html --&amp;gt;
&amp;lt;div&amp;gt;文件名注释示例&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;终端框架&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;这个终端框架没有标题&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;Write-Output &quot;这个有标题!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;覆盖框架类型&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;看，没有框架!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;# 如果不覆盖，这应该是一个终端框架
function Watch-Tail { Get-Content -Tail 20 -Wait $args }
New-Alias tail Watch-Tail
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;文本与行标记&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/text-markers/&quot;&gt;文本与行标记&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;标记整行和行范围js {1, 4, 7-8}&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 第 1 行 - 通过行号标记
// 第 2 行
// 第 3 行
// 第 4 行 - 通过行号标记
// 第 5 行
// 第 6 行
// 第 7 行 - 通过范围 &quot;7-8&quot; 标记
// 第 8 行 - 通过范围 &quot;7-8&quot; 标记
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;选择行标记类型 (mark, ins, del)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  console.log(&apos;这行标记为已删除&apos;)
  // 这行和下一行标记为已插入
  console.log(&apos;这是第二个插入的行&apos;)

  return &apos;这行使用中性的默认标记类型&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;为行标记添加标签jsx {&quot;1&quot;:5} del={&quot;2&quot;:7-8} ins={&quot;3&quot;:10-12}&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 带标签的行标记.jsx
&amp;lt;button
  role=&quot;button&quot;
  {...props}
  value={value}
  className={buttonClassName}
  disabled={disabled}
  active={active}
&amp;gt;
  {children &amp;amp;&amp;amp;
    !active &amp;amp;&amp;amp;
    (typeof children === &apos;string&apos; ? &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt; : children)}
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;在单独行上添加长标签&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;jsx {&quot;1. Provide the value prop here:&quot;:5-6} del={&quot;2. Remove the disabled and active states:&quot;:8-10} ins={&quot;3. Add this to render the children inside the button:&quot;:12-15}&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 带标签的行标记.jsx
&amp;lt;button
  role=&quot;button&quot;
  {...props}

  value={value}
  className={buttonClassName}

  disabled={disabled}
  active={active}
&amp;gt;

  {children &amp;amp;&amp;amp;
    !active &amp;amp;&amp;amp;
    (typeof children === &apos;string&apos; ? &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt; : children)}
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用类似 diff 的语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;+这行将标记为已插入
-这行将标记为已删除
这是常规行
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;--- a/README.md
+++ b/README.md
@@ -1,3 +1,4 @@
+这是一个实际的 diff 文件
-所有内容将保持未修改状态
 也不会删除任何空白字符
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;结合语法高亮和类似 diff 的语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  function thisIsJavaScript() {
    // 整个代码块将作为 JavaScript 高亮，
    // 我们仍然可以为其添加 diff 标记！
-   console.log(&apos;要移除的旧代码&apos;)
+   console.log(&apos;全新闪亮的代码!&apos;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;标记行内的特定文本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  // Mark any given text inside lines
  return &apos;Multiple matches of the given text are supported&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;正则表达式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;The words yes and yep will be marked.&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;转义正斜杠&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;Test&quot; &amp;gt; /home/test.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;选择行内标记类型 (mark, ins, del)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  console.log(&apos;These are inserted and deleted marker types&apos;);
  // The return statement uses the default marker type
  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自动换行&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/word-wrap/&quot;&gt;自动换行&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;按代码块配置自动换行&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Example with wrap
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(启用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// Example with wrap=false
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(禁用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;配置换行行的缩进&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Example with preserveIndent (enabled by default)
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(启用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// Example with preserveIndent=false
function getLongString() {
  return &apos;This is a very long string that will most probably not fit into the available space unless the container is extremely wide&apos;
  // 这是一个非常长的字符串，除非容器极其宽，否则很可能无法适应可用空间(禁用)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;可折叠部分&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/plugins/collapsible-sections/&quot;&gt;可折叠部分&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 所有这些样板设置代码将被折叠
import { someBoilerplateEngine } from &apos;@example/some-boilerplate&apos;
import { evenMoreBoilerplate } from &apos;@example/even-more-boilerplate&apos;

const engine = someBoilerplateEngine(evenMoreBoilerplate())

// 这部分代码默认可见
engine.doSomething(1, 2, 3, calcFn)

function calcFn() {
  // 可以有多个折叠部分
  const a = 1
  const b = 2
  const c = a + b

  // 这将保持可见
  console.log(`计算结果: ${a} + ${b} = ${c}`)
  return c
}

// 从这到代码块末尾的所有代码将再次被折叠
engine.closeConnection()
engine.freeMemory()
engine.shutdown({ reason: &apos;示例样板代码结束&apos; })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;行号&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/plugins/line-numbers/&quot;&gt;行号&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;按代码块显示行号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 这个代码块将显示行号
console.log(&apos;来自第 2 行的问候!&apos;)
console.log(&apos;我在第 3 行&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// 这个代码块禁用了行号
console.log(&apos;你好?&apos;)
console.log(&apos;抱歉，你知道我在第几行吗?&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;更改起始行号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;来自第 5 行的问候!&apos;)
console.log(&apos;我在第 6 行&apos;)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Fuwari 简单使用指南</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/fuwari-blog-guide/fuwari-blogguide/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/fuwari-blog-guide/fuwari-blogguide/</guid><description>如何使用此博客模板</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;封面图片来源: &lt;a href=&quot;https://image.civitai.com/xG1nkqKTMzGDvpLrqFT7WA/208fc754-890d-4adb-9753-2c963332675d/width=2048/01651-1456859105-(colour_1.5),girl,_Blue,yellow,green,cyan,purple,red,pink,_best,8k,UHD,masterpiece,male%20focus,%201boy,gloves,%20ponytail,%20long%20hair,.jpeg&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此博客模板基于 &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt; 构建。本指南未提及的内容，您可以在 &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro 文档&lt;/a&gt; 中找到答案。&lt;/p&gt;
&lt;h2&gt;文章的前言部分 (Front-matter)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: 我的第一篇博客文章
published: 2023-09-09
description: 这是我的新 Astro 博客的第一篇文章
image: ./cover.jpg
tags: [示例标签1, 示例标签2]
category: 前端开发
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章发布的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的简短描述。在首页显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The cover image path of the post.&amp;lt;br/&amp;gt;1. Start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: Use web image&amp;lt;br/&amp;gt;2. Start with &lt;code&gt;/&lt;/code&gt;: For image in &lt;code&gt;public&lt;/code&gt; dir&amp;lt;br/&amp;gt;3. With none of the prefixes: Relative to the markdown file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文章的分类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果文章仍是草稿，则不会显示&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;image翻译:
文章的封面图片路径。
1. 以 http:// 或 https:// 开头：使用网络图片
2. 以 / 开头：位于 public 目录中的图片
3. 无前缀：相对于 markdown 文件的路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;文章文件的存放位置&lt;/h2&gt;
&lt;p&gt;您的文章文件应放置在&lt;code&gt;src/content/posts/&lt;/code&gt; 目录下。您也可以创建子目录来更好地组织文章和资源文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Markdown 示例</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/markdown/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/markdown/</guid><description>一个简单的 Markdown 博客文章示例</description><pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;一级标题&lt;/h1&gt;
&lt;p&gt;段落之间用空行分隔。&lt;/p&gt;
&lt;p&gt;第二段落。&lt;em&gt;斜体&lt;/em&gt;、&lt;strong&gt;粗体&lt;/strong&gt;和&lt;code&gt;等宽字体&lt;/code&gt;。项目列表看起来像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个项目&lt;/li&gt;
&lt;li&gt;那个项目&lt;/li&gt;
&lt;li&gt;另一个项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意 --- 不考虑星号 --- 实际文本内容从第4列开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;块引用是
这样写的。&lt;/p&gt;
&lt;p&gt;如果你喜欢，它们可以
跨多个段落。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用3个破折号表示长破折号。使用2个破折号表示范围（例如，&quot;全部在第12--14章&quot;）。三个点...将被转换为省略号。
支持Unicode。☺&lt;/p&gt;
&lt;h2&gt;二级标题&lt;/h2&gt;
&lt;p&gt;这是一个编号列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再次注意实际文本如何从第4列开始（距离左侧4个字符）。这是一个代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 让我重申...
for i in 1 .. 10 { do-something(i) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如您所猜，缩进4个空格。顺便说一下，您可以使用分隔块来代替缩进块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define foobar() {
    print &quot;Welcome to flavor country!&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（这样更容易复制和粘贴）。您可以选择标记分隔块以便Pandoc进行语法高亮：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
# 快，数到十！
for i in range(10):
    # （但不要*太*快）
    time.sleep(0.5)
    print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;三级标题&lt;/h3&gt;
&lt;p&gt;现在是一个嵌套列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, get these ingredients:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;carrots&lt;/li&gt;
&lt;li&gt;celery&lt;/li&gt;
&lt;li&gt;lentils&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boil some water.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dump everything in the pot and follow
this algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; find wooden spoon
 uncover pot
 stir
 cover pot
 balance wooden spoon precariously on pot handle
 wait 10 minutes
 goto first step (or shut off burner when done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do not bump wooden spoon or it will fall.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再次注意文本如何始终对齐4空格缩进（包括上面继续第3项的最后一行）。&lt;/p&gt;
&lt;p&gt;Here&apos;s a link to &lt;a href=&quot;http://foo.bar&quot;&gt;a website&lt;/a&gt;, to a &lt;a href=&quot;local-doc.html&quot;&gt;local
doc&lt;/a&gt;, and to a &lt;a href=&quot;#an-h2-header&quot;&gt;section heading in the current
doc&lt;/a&gt;. Here&apos;s a footnote [^1].&lt;/p&gt;
&lt;p&gt;&lt;code&gt;这是一个指向网站的链接，指向本地文档的链接，以及指向当前文档中章节标题的链接&lt;/code&gt; &lt;code&gt;这是一个脚注&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[^1]: Footnote text goes here.
&lt;code&gt;这是一个脚注&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表格可以看起来像这样:&lt;/p&gt;
&lt;p&gt;(这个用不了 : Fuwari 主题使用的是标准 Markdown 解析器，不直接支持 Pandoc 特有的极简表格语法（如无竖线的表格）,这部分我用代码块括起来，不用看)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;size material color

---

9 leather brown
10 hemp canvas natural
11 glass transparent

Table: Shoes, their sizes, and what they&apos;re made of

(The above is the caption for the table.) Pandoc also supports
multi-line tables:

---

keyword text

---

red Sunsets, apples, and
other red or reddish
things.

green Leaves, grass, frogs
and other things it&apos;s
not easy being.

---

接下来是一条水平分割线。

---

这是一个定义列表：

苹果
: 适合做苹果酱。
橙子
: 柑橘类！
西红柿
: &quot;tomato&quot;中没有&quot;e&quot;。

同样，文本缩进4个空格。（在每个术语/定义对之间放一个空行以使内容更分散。）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准markdown下的表格文档为:&lt;/p&gt;
&lt;h2&gt;基础表格&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;年龄&lt;/th&gt;
&lt;th&gt;职业&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;张三&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;设计师&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;李四&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;开发者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;王五&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;产品经理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;带对齐方式的表格&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;左对齐内容&lt;/th&gt;
&lt;th&gt;居中对齐内容&lt;/th&gt;
&lt;th&gt;右对齐内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文本1&lt;/td&gt;
&lt;td&gt;文本2&lt;/td&gt;
&lt;td&gt;数值1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长文本示例&lt;/td&gt;
&lt;td&gt;居中文本&lt;/td&gt;
&lt;td&gt;12345&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这是一个&quot;行块&quot;：&lt;/p&gt;
&lt;p&gt;| 第一行
| 第二行
| 第三行&lt;/p&gt;
&lt;p&gt;图像可以这样指定：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[//]: # (![example image]&amp;amp;#40;./demo-banner.png &quot;An exemplary image&quot;&amp;amp;#41;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;行内数学方程这样插入：$\omega = d\phi / dt$。显示数学应该独占一行并用双美元符号括起来：&lt;/p&gt;
&lt;p&gt;$$I = \int \rho R^{2} dV$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation*}
\pi
=3.1415926535
;8979323846;2643383279;5028841971;6939937510;5820974944
;5923078164;0628620899;8628034825;3421170679;\ldots
\end{equation*}
$$&lt;/p&gt;
&lt;p&gt;And note that you can backslash-escape any punctuation characters which you wish to be displayed literally, ex.: &lt;code&gt;foo&lt;/code&gt;, &lt;em&gt;bar&lt;/em&gt;, etc.
&lt;code&gt;请注意，您可以用反斜杠转义任何希望按字面显示的标点字符，例如：&lt;/code&gt;foo&lt;code&gt;、*bar*等。&lt;/code&gt;&lt;/p&gt;
</content:encoded></item><item><title>在文章中嵌入视频</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/video/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/video/</guid><description>本文演示如何在博客文章中嵌入视频。</description><pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;只需从 YouTube 或其他平台复制嵌入代码，然后粘贴到 markdown 文件中即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: 在文章中嵌入视频
published: 2023-10-19
// ...
---

&amp;lt;iframe 
    width=&quot;100%&quot; 
    height=&quot;468&quot; 
    src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; 
    title=&quot;YouTube 视频播放器&quot; 
    frameborder=&quot;0&quot; 
    allowfullscreen&amp;gt;
&amp;lt;/iframe&amp;gt;

# 属性有下面这些
# &amp;lt;iframe 
#   width=&quot;100%&quot; 
#   height=&quot;400&quot; 
#   src=&quot;https://www.youtube.com/embed/视频ID&quot; 
#   title=&quot;视频标题&quot;
#   frameborder=&quot;0&quot; 
#   allowfullscreen&amp;gt;
# &amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube 视频播放器&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>草稿示例</title><link>https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/draft/</link><guid isPermaLink="true">https://derckhanna.github.io/ForestBlog-Source/posts/blog-guide/draft/</guid><pubDate>Fri, 01 Jul 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;本文是草稿&lt;/h2&gt;
&lt;p&gt;本文目前处于草稿状态，尚未发布。因此，普通观众将无法看到。内容仍在完善中，可能需要进一步的编辑和审阅。&lt;/p&gt;
&lt;p&gt;当文章准备好发布时，您可以在 Frontmatter 中将 &quot;draft&quot; 字段更新为 &quot;false&quot;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: 草稿示例
published: 2024-01-11T04:40:26.381Z
tags: [Markdown, 博客, 示例]
category: 示例
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item></channel></rss>